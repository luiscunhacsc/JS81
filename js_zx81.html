<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS ZX81 Pro</title>
    <style>
        :root {
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --accent-gray: #aaaaaa;
            --accent-red: #d00000;
            --text-color: #e0e0e0;
            --font-ui: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-ui);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .header h1 {
            margin: 0 0 20px 0;
            font-weight: 300; letter-spacing: 6px; font-size: 24px; text-transform: uppercase;
            background: linear-gradient(90deg, #fff, #888, #fff);
            -webkit-background-clip: text; background-clip: text; color: transparent;
            text-shadow: 0 0 10px rgba(255,255,255,0.1);
        }

        .monitor-frame {
            position: relative; background: #000; padding: 20px;
            border-radius: 12px;
            box-shadow: 0 0 0 4px #333, 0 30px 60px rgba(0,0,0,0.8);
            transition: box-shadow 0.1s;
        }

        .canvas-wrapper {
            width: 640px; height: 480px;
            background: #000; border-radius: 4px; overflow: hidden; outline: none; cursor: pointer;
        }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); backdrop-filter: blur(5px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease; z-index: 10;
        }
        .overlay.active { opacity: 1; pointer-events: auto; }
        .overlay img { max-width: 95%; max-height: 85%; border-radius: 4px; border: 1px solid #444; }
        .overlay-hint { margin-top: 15px; font-size: 14px; color: #aaa; }

        .controls-panel {
            margin-top: 25px; background: var(--panel-color); padding: 15px 25px; border-radius: 50px;
            display: flex; gap: 15px; align-items: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); border: 1px solid #333;
        }
        .btn {
            background: #333; color: #fff; border: none; padding: 10px 20px; border-radius: 20px;
            font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s ease;
            display: flex; align-items: center; gap: 8px; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .btn:hover:not(:disabled) { background: #444; transform: translateY(-1px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .btn.rom-btn { background: #444; border: 1px solid #666; }
        .btn.primary { background: #666; color: white; border: 1px solid #888; }
        
        /* Botão EXIT */
        .btn.danger { background: #800000; color: #ffcccc; margin-left: 20px; border: 1px solid #a00000; }
        .btn.danger:hover { background: #a00000; box-shadow: 0 0 10px rgba(255,0,0,0.3); }

        input[type="file"] { display: none; }
        .status-bar { margin-top: 15px; font-family: monospace; font-size: 12px; color: #666; min-height: 15px; }
        
        .footer-credits {
            margin-top: 30px; font-size: 11px; color: #444; opacity: 0.7; letter-spacing: 1px; text-transform: uppercase;
        }
    </style>

    <script> var module = {}; </script>
    <script src="Z80.js"></script>
    <script>
        const Z80_CPU = (typeof Z80 === 'function') ? Z80 : (module.exports || window.Z80);
        if (!Z80_CPU) alert("Critical Error: Z80.js not loaded.");
    </script>
</head>
<body>

    <div class="header"><h1>JS ZX81</h1></div>

    <div class="monitor-frame" id="monitor">
        <div class="canvas-wrapper" id="container" tabindex="0">
            <canvas id="screen" width="256" height="192"></canvas>
            <div id="keyboardOverlay" class="overlay">
                <img src="keyboard.png" alt="ZX81 Keyboard Layout">
                <div class="overlay-hint">Press <b>F1</b> to close</div>
            </div>
        </div>
    </div>

    <div class="status-bar"><span id="statusMsg">Initializing...</span></div>

    <div class="controls-panel">
        <label class="btn rom-btn">
            1. ROM
            <input type="file" id="romFile">
        </label>

        <label class="btn primary">
            2. Load Game (.P)
            <input type="file" id="tapFile" accept=".p,.P" disabled>
        </label>
        
        <button id="btnReset" class="btn" disabled>Reset</button>
        <button class="btn" onclick="toggleKeyboard()">Map (F1)</button>
        
        <button class="btn danger" onclick="exitEmulator()">EXIT</button>
    </div>
    
    <div style="margin-top:15px; font-size: 12px; color: #555;">
        <b>Shift</b> = Shift &nbsp;|&nbsp; <b>Ctrl</b> = Symbol/Function
    </div>

    <div class="footer-credits">
        &copy; 2025 Luís Simões da Cunha
    </div>

<script>
/**
 * JS ZX81 EMULATOR (Fixed Inputs & Exit)
 * Author: Luís Simões da Cunha (2025)
 */

const MEM_SIZE = 65536;
const memory = new Uint8Array(MEM_SIZE);
let z80 = null;
let isRunning = false;
let animationFrameId;

// ZX81 Matrix Constants
const keyboard = {
    0xFEFE: 0x1F, 0xFDFE: 0x1F, 0xFBFE: 0x1F, 0xF7FE: 0x1F,
    0xEFFE: 0x1F, 0xDFFE: 0x1F, 0xBFFE: 0x1F, 0x7FFE: 0x1F
};

const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d');
const imgData = ctx.createImageData(256, 192);
const pixels = new Uint32Array(imgData.data.buffer);

const COL_BACK = 0xFFCCCCCC; 
const COL_INK  = 0xFF000000; 

// --- ROM LOADING ---
window.addEventListener('load', async () => {
    document.getElementById('container').focus();
    log("Attempting auto-load of 'zx81.rom'...");
    try {
        const response = await fetch('zx81.rom');
        if (!response.ok) throw new Error("File not found or blocked.");
        const buffer = await response.arrayBuffer();
        loadRomData(new Uint8Array(buffer));
    } catch (e) {
        log("Auto-load failed. Click '1. ROM' to select zx81.rom manually.", 'error');
    }
});

document.getElementById('romFile').addEventListener('change', (e) => {
    const r = new FileReader();
    r.onload = (ev) => { loadRomData(new Uint8Array(ev.target.result)); };
    r.readAsArrayBuffer(e.target.files[0]);
});

function loadRomData(data) {
    for(let i=0; i<data.length && i<8192; i++) memory[i] = data[i];
    initZ80();
    log("ROM Loaded. System Ready.", 'success');
}

function exitEmulator() {
    // 1. Stop Loop
    isRunning = false;
    if(animationFrameId) cancelAnimationFrame(animationFrameId);
    
    // 2. Kill Z80
    z80 = null;
    
    // 3. Clear Screen (Power Off effect)
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, 256, 192);
    
    // 4. Update UI
    log("SYSTEM HALTED. YOU CAN CLOSE THIS TAB.", 'error');
    document.querySelector('.controls-panel').style.display = 'none';
    document.querySelector('.header h1').innerText = "POWER OFF";
    
    // 5. Try to close window
    try {
        window.close();
    } catch(e) {
        console.log("Browser prevented auto-close.");
    }
}

function log(msg, type) {
    const el = document.getElementById('statusMsg');
    el.innerText = msg;
    el.style.color = type === 'error' ? '#ff4444' : (type === 'success' ? '#00cc00' : '#888');
}

function toggleKeyboard() {
    const overlay = document.getElementById('keyboardOverlay');
    overlay.classList.toggle('active');
    if (!overlay.classList.contains('active')) document.getElementById('container').focus();
}

function initZ80() {
    z80 = new Z80_CPU({
        mem_read: (addr) => {
            if (addr < 0x4000) return memory[addr & 0x1FFF]; 
            if (addr >= 0x4000 && addr < 0x8000) return memory[addr]; 
            if (addr >= 0xC000) return memory[addr & 0x7FFF];
            return 0xFF;
        },
        mem_write: (addr, val) => {
            if (addr >= 0x4000 && addr < 0x8000) memory[addr] = val;
        },
        io_read: (port) => {
            // ULA Port FE
            if ((port & 0xFF) === 0xFE) {
                let result = 0x1F; 
                const rowSelect = (port >> 8) & 0xFF;
                
                // Active Low Scanning
                if (!(rowSelect & 0x01)) result &= keyboard[0xFEFE];
                if (!(rowSelect & 0x02)) result &= keyboard[0xFDFE];
                if (!(rowSelect & 0x04)) result &= keyboard[0xFBFE];
                if (!(rowSelect & 0x08)) result &= keyboard[0xF7FE];
                if (!(rowSelect & 0x10)) result &= keyboard[0xEFFE];
                if (!(rowSelect & 0x20)) result &= keyboard[0xDFFE];
                if (!(rowSelect & 0x40)) result &= keyboard[0xBFFE];
                if (!(rowSelect & 0x80)) result &= keyboard[0x7FFE];
                
                // Bit 6 must be LOW for UK/50Hz
                return 0xBF | result; 
            }
            return 0xFF;
        },
        io_write: (port, val) => {}
    });

    document.getElementById('btnReset').disabled = false;
    document.getElementById('tapFile').disabled = false;
    resetSystem();
}

function resetSystem() {
    if(!z80) return;
    z80.reset();
    for(let i=0x4000; i<0x8000; i++) memory[i] = 0;
    isRunning = true;
    if(animationFrameId) cancelAnimationFrame(animationFrameId);
    document.getElementById('container').focus();
    loop();
    log("Reset complete. K Cursor should appear.", 'normal');
}

function loop() {
    if (!isRunning) return;
    let tStates = 0;
    while(tStates < 65000) tStates += z80.run_instruction();
    z80.interrupt(false, 0);
    renderScreen();
    animationFrameId = requestAnimationFrame(loop);
}

document.getElementById('tapFile').addEventListener('change', (e) => {
    const r = new FileReader();
    r.onload = (ev) => { loadPFile(new Uint8Array(ev.target.result)); };
    r.readAsArrayBuffer(e.target.files[0]);
});

function loadPFile(data) {
    if(!z80) return;
    log(`Loading .P file (${data.length} bytes)...`);
    
    let startAddr = 0x4009;
    for(let i=0; i<data.length; i++) {
        if(startAddr + i < 0x8000) memory[startAddr + i] = data[i];
    }
    
    // System Vars Fixup
    let sp = 0x8000 - 4;
    memory[0x4000] = 0xFF; memory[0x4001] = 0x80;
    memory[0x4002] = sp & 0xFF; memory[0x4003] = sp >> 8;
    memory[0x4004] = (sp+4) & 0xFF; memory[0x4005] = (sp+4) >> 8;
    memory[0x4006] = 0x00; memory[0x4007] = 0xFE; memory[0x4008] = 0xFF; 

    let state = z80.getState();
    state.pc = 0x0207; 
    state.sp = sp;     
    state.ix = 0x0281; state.iy = 0x4000;
    state.i = 0x1E; state.r = 0xDD; state.imode = 1;
    z80.setState(state);
    
    log("Game Loaded. Focus screen to play.", 'success');
    document.getElementById('container').focus();
}

function renderScreen() {
    pixels.fill(COL_BACK);
    const dFile = memory[0x400C] | (memory[0x400D] << 8);
    if (dFile < 0x4000 || dFile > 0x7FFF) return;

    let ptr = dFile + 1;
    let row = 0, col = 0, bytesRead = 0;

    while (bytesRead < 800 && row < 24) {
        const charCode = memory[ptr];
        if (charCode === 0x76) { row++; col = 0; } 
        else {
            if (col < 32) drawChar(col * 8, row * 8, charCode);
            col++;
        }
        ptr++; bytesRead++;
    }
    ctx.putImageData(imgData, 0, 0);
}

function drawChar(x, y, code) {
    let isInverse = (code & 0x80) !== 0;
    let baseCode = code & 0x3F;
    let romAddr = 0x1E00 + (baseCode * 8);
    for (let r = 0; r < 8; r++) {
        let byte = memory[romAddr + r]; 
        if (isInverse) byte = ~byte; 
        for (let c = 0; c < 8; c++) {
            if (byte & (0x80 >> c)) {
                let pIdx = ((y + r) * 256) + (x + c);
                pixels[pIdx] = COL_INK;
            }
        }
    }
}

// --- FIXED KEY MAPPING (Using 'code' for reliability) ---
const keyMap = { 
    'Digit1': [0xF7FE, 0x01], 'Digit2': [0xF7FE, 0x02], 'Digit3': [0xF7FE, 0x04], 'Digit4': [0xF7FE, 0x08], 'Digit5': [0xF7FE, 0x10],
    'Digit6': [0xEFFE, 0x10], 'Digit7': [0xEFFE, 0x08], 'Digit8': [0xEFFE, 0x04], 'Digit9': [0xEFFE, 0x02], 'Digit0': [0xEFFE, 0x01],
    'KeyQ': [0xFBFE, 0x01], 'KeyW': [0xFBFE, 0x02], 'KeyE': [0xFBFE, 0x04], 'KeyR': [0xFBFE, 0x08], 'KeyT': [0xFBFE, 0x10],
    'KeyY': [0xDFFE, 0x10], 'KeyU': [0xDFFE, 0x08], 'KeyI': [0xDFFE, 0x04], 'KeyO': [0xDFFE, 0x02], 'KeyP': [0xDFFE, 0x01],
    'KeyA': [0xFDFE, 0x01], 'KeyS': [0xFDFE, 0x02], 'KeyD': [0xFDFE, 0x04], 'KeyF': [0xFDFE, 0x08], 'KeyG': [0xFDFE, 0x10],
    'KeyH': [0xBFFE, 0x10], 'KeyJ': [0xBFFE, 0x08], 'KeyK': [0xBFFE, 0x04], 'KeyL': [0xBFFE, 0x02], 'Enter': [0xBFFE, 0x01],
    'ShiftLeft': [0xFEFE, 0x01], 'ShiftRight': [0xFEFE, 0x01], 
    'KeyZ': [0xFEFE, 0x02], 'KeyX': [0xFEFE, 0x04], 'KeyC': [0xFEFE, 0x08], 'KeyV': [0xFEFE, 0x10],
    'KeyB': [0x7FFE, 0x10], 'KeyN': [0x7FFE, 0x08], 'KeyM': [0x7FFE, 0x04], 'Period': [0x7FFE, 0x02], 'Space': [0x7FFE, 0x01],
    'ControlLeft': [0x7FFE, 0x02], 'ControlRight': [0x7FFE, 0x02] // Ctrl mapped to Symbol Shift (Period/Sym)
};

document.addEventListener('keydown', (e) => {
    if (e.key === 'F1') { e.preventDefault(); toggleKeyboard(); return; }
    if (!isRunning) return;
    
    // Usar 'e.code' para ser independente do layout (ex: AZERTY vs QWERTY)
    let mapping = keyMap[e.code];
    if (mapping) { 
        keyboard[mapping[0]] &= ~mapping[1]; // Press
        e.preventDefault(); 
    }
});

document.addEventListener('keyup', (e) => {
    let mapping = keyMap[e.code];
    if (mapping) {
        keyboard[mapping[0]] |= mapping[1]; // Release
    }
});

document.getElementById('btnReset').addEventListener('click', resetSystem);
// Force focus on click to ensure keyboard events work
document.getElementById('container').addEventListener('click', function() { this.focus(); });

</script>
</body>
</html>