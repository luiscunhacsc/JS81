<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS ZX81 I/O Debugger</title>
    <style>
        body { background: #111; color: #0f0; font-family: monospace; display: flex; gap: 20px; padding: 20px; }
        .monitor { border: 4px solid #333; display: inline-block; }
        canvas { display: block; image-rendering: pixelated; width: 320px; height: 240px; background: #000; }
        .log-panel { flex-grow: 1; display: flex; flex-direction: column; gap: 10px; }
        textarea { width: 100%; height: 400px; background: #222; color: #fff; font-family: monospace; font-size: 11px; border: 1px solid #444; }
        .controls { background: #222; padding: 10px; border-radius: 8px; }
        button { cursor: pointer; padding: 5px 10px; background: #444; color: #fff; border: 1px solid #666; }
        .status { color: yellow; margin-top: 5px; }
    </style>
    <script> var module = {}; </script>
    <script src="Z80.js"></script>
    <script>const Z80_CPU = (typeof Z80 === 'function') ? Z80 : (module.exports || window.Z80);</script>
</head>
<body>

    <div>
        <h1>IO DEBUGGER</h1>
        <div class="monitor"><canvas id="screen" width="256" height="192"></canvas></div>
        <div class="controls">
            <label>1. ROM <input type="file" id="romFile"></label>
            <button id="btnReset" disabled>2. RESET</button>
            <div class="status" id="statusMsg">Load ROM to start</div>
        </div>
        <p>Instructions:<br>1. Load ROM & Reset.<br>2. <b>HOLD '1'</b> for 3 seconds.<br>3. Check Log.</p>
    </div>

    <div class="log-panel">
        <h3>I/O TRAFFIC LOG</h3>
        <textarea id="ioLog" readonly>Waiting for inputs...</textarea>
        <button onclick="downloadLog()">Download Debug Log</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

<script>
/**
 * JS ZX81 I/O DEBUGGER
 */

const MEM_SIZE = 65536;
const memory = new Uint8Array(MEM_SIZE);
let z80 = null;
let isRunning = false;
let animationFrameId;
let ioLogData = [];
let logCounter = 0;

// Matrix Array (0xFF = Released)
const keyboardRows = new Uint8Array(8).fill(0x1F); 

const canvas = document.getElementById('screen');
const ctx = canvas.getContext('2d');
const imgData = ctx.createImageData(256, 192);
const pixels = new Uint32Array(imgData.data.buffer);
const COL_BACK = 0xFFCCCCCC; 
const COL_INK  = 0xFF000000; 

// --- DEBUG LOGGER ---
function logIO(port, rowSelect, result, keyPressActive) {
    // Only log if a key is physically being pressed by user to reduce spam
    if (!keyPressActive && logCounter > 50) return; 
    
    // Only log keyboard ports
    if ((port & 0xFF) !== 0xFE) return;

    if (logCounter > 2000) return; // Limit total log lines to prevent browser crash

    const hex = (n) => n.toString(16).toUpperCase().padStart(2, '0');
    const hex16 = (n) => n.toString(16).toUpperCase().padStart(4, '0');
    
    // Check if the result indicates a keypress (bit 0-4 low)
    const keyDetected = (result & 0x1F) !== 0x1F;
    const marker = keyDetected ? " <<< KEY HIT" : "";
    
    const entry = `PC:${hex16(z80.getState().pc)} | PORT:${hex16(port)} | ROW_SEL:${hex(rowSelect)} | RES:${hex(result)} (${result.toString(2)})${marker}`;
    
    ioLogData.push(entry);
    logCounter++;
    
    if (logCounter % 10 === 0) {
        document.getElementById('ioLog').value = ioLogData.join('\n');
    }
}

function downloadLog() {
    const blob = new Blob([ioLogData.join('\n')], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `zx81_io_debug.txt`;
    a.click();
}
function clearLog() { ioLogData = []; logCounter = 0; document.getElementById('ioLog').value = ""; }

// --- KEY MAPPING ---
// Simple map for digit '1' to verify connection
const keyMap = {
    'Digit1': [3, 1], // Row 3, Bit 0
    'KeyP': [5, 1],   // Row 5, Bit 0
    'Enter': [6, 1]
};

let isAnyKeyPressed = false;

document.addEventListener('keydown', (e) => {
    if (!isRunning) return;
    const m = keyMap[e.code];
    if (m) { 
        keyboardRows[m[0]] &= ~m[1];
        isAnyKeyPressed = true;
        // Reset log counter on press to capture this specific event
        if(logCounter > 1000) { ioLogData = []; logCounter = 0; } 
    }
});

document.addEventListener('keyup', (e) => {
    const m = keyMap[e.code];
    if (m) {
        keyboardRows[m[0]] |= m[1];
        isAnyKeyPressed = false;
    }
});

// --- CORE ---
function initZ80() {
    z80 = new Z80_CPU({
        mem_read: (addr) => {
            if (addr < 0x4000) return memory[addr & 0x1FFF]; 
            if (addr >= 0x4000 && addr < 0x8000) return memory[addr]; 
            if (addr >= 0xC000) return memory[addr & 0x7FFF];
            return 0xFF;
        },
        mem_write: (addr, val) => {
            if (addr >= 0x4000 && addr < 0x8000) memory[addr] = val;
        },
        io_read: (port) => {
            // ZX81 Port 0xFE
            if ((port & 0x1) === 0) {
                let rowSelect = (port >> 8) & 0xFF;
                
                // --- DEBUG PROBE START ---
                // If Z80.js sends 8-bit port, rowSelect is 0. 
                // We try to grab from A to see if that helps.
                let source = "PORT";
                if (rowSelect === 0) {
                     const s = z80.getState();
                     rowSelect = s.a;
                     source = "REG_A";
                }
                // --- DEBUG PROBE END ---

                let result = 0x1F;
                
                // Logic: If the bit in rowSelect is ZERO, we scan that row
                // This means 'rowSelect' acts as a mask.
                
                // We iterate all 8 rows. 
                // Row 0 corresponds to Bit 0 of High Byte (FE)
                // Row 1 corresponds to Bit 1 of High Byte (FD)...
                
                for(let r=0; r<8; r++) {
                    // If the specific bit for this row is LOW (0)
                    if ( !((rowSelect >> r) & 1) ) {
                        result &= keyboardRows[r];
                    }
                }

                // Force upper bits for valid ULA response
                const final = 0xE0 | result;
                
                // LOG IT
                logIO(port, rowSelect, final, isAnyKeyPressed);
                
                return final;
            }
            return 0xFF;
        },
        io_write: (port, val) => {}
    });

    document.getElementById('btnReset').disabled = false;
    resetSystem();
}

function resetSystem() {
    if(!z80) return;
    z80.reset();
    for(let i=0x4000; i<0x8000; i++) memory[i] = 0;
    // Clear Matrix
    for(let i=0; i<8; i++) keyboardRows[i] = 0x1F;
    
    isRunning = true;
    if(animationFrameId) cancelAnimationFrame(animationFrameId);
    document.getElementById('screen').focus();
    ioLogData = ["--- START LOG ---"];
    loop();
    document.getElementById('statusMsg').innerText = "Running. Hold '1' to debug.";
}

function loop() {
    if (!isRunning) return;
    let tStates = 0;
    while(tStates < 65000) tStates += z80.run_instruction();
    z80.interrupt(false, 0);
    renderScreen();
    animationFrameId = requestAnimationFrame(loop);
}

document.getElementById('romFile').addEventListener('change', (e) => {
    const r = new FileReader();
    r.onload = (ev) => { 
        const d = new Uint8Array(ev.target.result);
        for(let i=0; i<d.length && i<8192; i++) memory[i] = d[i];
        initZ80();
        document.getElementById('statusMsg').innerText = "ROM Loaded. Resetting...";
    };
    r.readAsArrayBuffer(e.target.files[0]);
});
document.getElementById('btnReset').addEventListener('click', resetSystem);

function renderScreen() {
    pixels.fill(COL_BACK);
    const dFile = memory[0x400C] | (memory[0x400D] << 8);
    if (dFile < 0x4000 || dFile > 0x7FFF) return;
    let ptr = dFile + 1;
    let row = 0, col = 0, bytesRead = 0;
    while (bytesRead < 800 && row < 24) {
        const charCode = memory[ptr];
        if (charCode === 0x76) { row++; col = 0; } 
        else {
            if (col < 32) drawChar(col * 8, row * 8, charCode);
            col++;
        }
        ptr++; bytesRead++;
    }
    ctx.putImageData(imgData, 0, 0);
}

function drawChar(x, y, code) {
    let isInverse = (code & 0x80) !== 0;
    let baseCode = code & 0x3F;
    let romAddr = 0x1E00 + (baseCode * 8);
    for (let r = 0; r < 8; r++) {
        let byte = memory[romAddr + r]; 
        if (isInverse) byte = ~byte; 
        for (let c = 0; c < 8; c++) {
            if (byte & (0x80 >> c)) {
                let pIdx = ((y + r) * 256) + (x + c);
                pixels[pIdx] = COL_INK;
            }
        }
    }
}
</script>
</body>
</html>v